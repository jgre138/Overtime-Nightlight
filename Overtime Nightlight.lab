{"identifier":"f8eb595f-879d-45cb-92bd-abf8d6b4328c","name":"Untitled Program (2)","summary":"","data":"15;javascript&/*  \n    Overtime Nightlight \n    Code written by Jennifer Green\n    For group project in CS-104\n    Current date: 11/7/2025\n    GitHub Repository: https://github.com/jgre138/Overtime-Nightlight\n*/\n\n\n//  --- VARIABLES ---\nconst WAIT_TIME = 10;             // # of seconds to wait for tap\nconst TASK_TIME = 30;             //30 seconds for demo purposes (might change to )\nconst TAP_THRESHOLD = 1.05;       //  G threshold for tap detection\nlet userFound = false;\nlet tripDone = false;\nlet doorUser = 'A';             //This is the door the robot will ALWAYS start at for this demo.\n\n\n//  --- TAP FUNCTION ---\nasync function detectTap(timeout) { //  Detect tap via accelerometer spike (DO NOT TOUCH, THIS WORKS)\n    let a;\n    let mag;\n    let waited = 0.0;\n    while (waited < timeout) {\n        a = getAcceleration(); //gets the acceleration or any changes in it during the wait time\n        mag = (a[\"x\"] ** 2 + a[\"y\"] ** 2 + a[\"z\"] ** 2) ** 0.5; //calculates total accel in all directions\n        if (mag >= TAP_THRESHOLD) { //checks if total accel is above a set threshold\n            return true; //change in accelerometer detected in wait time\n        }\n        await delay(0.1);\n        waited += 0.1;\n    } \n    return false; // no change detected\n}\n\n//  --- CHECK USER ---\nasync function checkForUser() { //  Checks for user input to continue\n    setMainLed({ \"r\": 255, \"g\": 255, \"b\": 255 }); //  white flash;\n    let tapped = await detectTap(WAIT_TIME);\n    if (tapped) {\n        setMainLed({ \"r\": 0, \"g\": 255, \"b\": 0 }); //  green confirm;\n        await speak(\"User is here! Lets go!\", false); \n        //  user is at A along with robot;\n        userFound = true;\n    } else {\n        setMainLed({ \"r\": 255, \"g\": 0, \"b\": 0 }); //  red timeout;\n        await speak(\"User is not here, let me check the other door.\", false); \n        // User is at the other door\n        userFound = false;\n    }\n    \n}\n\n//  --- DOOR MOVEMENT ---\nasync function goToDoorA() {\n    // add a special light to signal its searching\n    await rollToDistance(0, 50, 100); //39 in\n    await rollToDistance(270, 50, 398); //153 In +\n    await rollToDistance(180, 50, 40); //15.5 in\n    await rollToDistance(270, 50, 280); //108 +\n    await rollToDistance(0, 50, 40); //15.5 in\n    await rollToDistance(270, 50, 245); //96 in +\n    await rollToDistance(180, 50, 100); // 39 in\n}\n\nasync function goToDoorB() {\n    // add a special light to signal its searching\n    await rollToDistance(0, 50, 100); //39 in\n    await rollToDistance(90, 50, 245); //96 in + 1\n    await rollToDistance(180, 50, 40); //15.5 in\n    await rollToDistance(90, 50, 280); //108 in + 2??\n    await rollToDistance(0, 50, 40);  // 15.5 in\n    await rollToDistance(90, 50, 398); //153 In +\n    await rollToDistance(180, 50, 100); //39 in\n    \n    // This pathing is finicky as you need to have the robot facing exactly forward\n    // I will be working to fix this wfor week 10\n}\n\n//  --- TASK MOVEMENT --- \nasync function goToTask1(){\n    if (doorUser == 'A'){ //Move to the task from door a as starting position\n        await rollToDistance(0, 50, 100); //39 in\n        await rollToDistance(90, 50, 245); //96 in + 1\n        await rollToDistance(180, 50, 40); //15.5 in\n        await rollToDistance(90, 50, 280); //108 in + 2??\n        await rollToDistance(0, 50, 40); //15.5 in\n        await rollToDistance(90, 50, 398); //153 In +\n        await rollToDistance(0, 50, 453); // 178 1/4 In\n    }\n    else if (doorUser == 'B'){ //move to task from door b as starting position\n        await rollToDistance(0, 50, 572); //225 in\n    } \n}\n\nasync function goTotask2(){\n    await rollToDistance(270, 50, 183); // 72 in     \n}\n\nasync function goFromTask(){\n    if (doorUser == 'A') { //Move from the task to door b\n        await rollToDistance(90, 50, 183); // 72 inch\n        await rollToDistance(180, 50, 572); //225 in\n    }\n    else if (doorUser == 'B') { //move from task from door a\n        await rollToDistance(90, 50, 183); // 72 inch\n        await rollToDistance(180, 50, 453); // 178 1/4 In\n        await rollToDistance(270, 50, 398); //153 In +\n        await rollToDistance(180, 50, 40); //15.5 in\n        await rollToDistance(270, 50, 280); //108 in + 2??\n        await rollToDistance(0, 50, 40); //15.5 in\n        await rollToDistance(270, 50, 245); //96 in + 1\n        await rollToDistance(180, 50, 100); //39 in\n    }\n}\n\n//  --- MAIN PROCESS ---\nasync function startWork() { // need to rework this entire function\n    while (tripDone != true) {\n        await speak(\"Good afternoon, ready to do some work?\", false);\n        await checkForUser();\n        if (userFound) { // will not change the door user is currently at.\n            await goToTask1();\n            let taskComplete = detectTap(TASK_TIME);\n            //add stuff here lol\n            \n            tripDone = true;\n            await delay(2);\n            playMatrixAnimation(0, false);// Checkmark\n            await delay(3);\n            await speak(\"Shuttle complete!\", false);\n        } \n        else if (!userFound && doorUser == 'B'){  //If they dont catch user at door A and doent find them at B\n            await goToDoorA(); //Goes to other door to find the user\n            await delay(1);\n            doorUser = 'A';\n        }\n        else {\n            await goToDoorB();\n            doorUser = 'B';\n        }\n    } \n}\nasync function doorTest(){  //WORKING\n    await speak(\"Going to door B\");\n    await delay(1);\n    await goToDoorB();\n    await delay(1);\n    await speak(\"Made it to door B\");\n    await delay(10)\n    await goToDoorA();\n    await delay(1)\n    await speak(\"Made it to door A\")\n\n}\n\nasync function testTaskRouteA(){\n    doorUser = 'A'\n    await goToTask1();\n    await delay(1);\n    await speak(\"made it to task 1\");\n    await delay(1)\n    await goTotask2();\n    await delay(1);\n    await speak(\"made it to task 2\");\n    await delay(1)\n    await goFromTask();\n    await delay(1);\n    await speak(\"made it to other door\");\n}\n\nasync function testTaskRouteB(){\n    doorUser = 'B'\n    await goToTask1();\n    await delay(1);\n    await speak(\"made it to task 1\");\n    await delay(1)\n    await goTotask2();\n    await delay(1);\n    await speak(\"made it to task 2\");\n    await delay(1)\n    await goFromTask();\n    await delay(1);\n    await speak(\"made it to other door\");\n}\n\n\n//  --- MAIN PROGRAM ---;\nasync function startProgram() {\n    //  ALWAYS start at Door A (A is Home). \n    //  In this case, Door A is the one by the classroom PC.\n    await testTaskRouteA();\n}\n\nasync function OnButton(){ // make this a debug mode???\n    await speak(\"Process being interupted, apologies.\")\n    tripDone = true;\n}\n\n//  use for future refrence\n//  playMatrixAnimation(0, false); //checkmark\n//  playMatrixAnimation(1, false); //go\n//  playMatrixAnimation(2, false); //slowdown\n//  playMatrixAnimation(3, false); //stop\n//  playMatrixAnimation(4, false); //checkbox\n//  playMatrixAnimation(5, true);  //checking the box\n\n\nregisterMatrixAnimation({\n    frames: [[[1, 1, 1, 1, 1, 1, 1, 8], [1, 1, 1, 1, 1, 1, 8, 8], [1, 1, 1, 1, 1, 8, 8, 8], [1, 1, 1, 1, 8, 8, 8, 1], [8, 8, 1, 8, 8, 8, 1, 1], [8, 8, 8, 8, 8, 1, 1, 1], [1, 8, 8, 8, 1, 1, 1, 1], [1, 1, 8, 1, 1, 1, 1, 1]]],\n    palette: [{ r: 255, g: 255, b: 255 }, { r: 0, g: 0, b: 0 }, { r: 255, g: 0, b: 0 }, { r: 255, g: 64, b: 0 }, { r: 255, g: 128, b: 0 }, { r: 255, g: 191, b: 0 }, { r: 255, g: 255, b: 0 }, { r: 185, g: 246, b: 30 }, { r: 0, g: 255, b: 0 }, { r: 185, g: 255, b: 255 }, { r: 0, g: 255, b: 255 }, { r: 0, g: 0, b: 255 }, { r: 145, g: 0, b: 211 }, { r: 157, g: 48, b: 118 }, { r: 255, g: 0, b: 255 }, { r: 204, g: 27, b: 126 }],\n    fps: 10,\n    transition: MatrixAnimationTransition.None\n});\nregisterMatrixAnimation({\n    frames: [[[1, 1, 8, 8, 8, 8, 1, 1], [1, 8, 8, 8, 8, 8, 8, 1], [8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8], [1, 8, 8, 8, 8, 8, 8, 1], [1, 1, 8, 8, 8, 8, 1, 1]]],\n    palette: [{ r: 255, g: 255, b: 255 }, { r: 0, g: 0, b: 0 }, { r: 255, g: 0, b: 0 }, { r: 255, g: 64, b: 0 }, { r: 255, g: 128, b: 0 }, { r: 255, g: 191, b: 0 }, { r: 255, g: 255, b: 0 }, { r: 185, g: 246, b: 30 }, { r: 0, g: 255, b: 0 }, { r: 185, g: 255, b: 255 }, { r: 0, g: 255, b: 255 }, { r: 0, g: 0, b: 255 }, { r: 145, g: 0, b: 211 }, { r: 157, g: 48, b: 118 }, { r: 255, g: 0, b: 255 }, { r: 204, g: 27, b: 126 }],\n    fps: 10,\n    transition: MatrixAnimationTransition.None\n});\nregisterMatrixAnimation({\n    frames: [[[1, 1, 6, 6, 6, 6, 1, 1], [1, 6, 6, 6, 6, 6, 6, 1], [6, 6, 6, 6, 6, 6, 6, 6], [6, 6, 6, 6, 6, 6, 6, 6], [6, 6, 6, 6, 6, 6, 6, 6], [6, 6, 6, 6, 6, 6, 6, 6], [1, 6, 6, 6, 6, 6, 6, 1], [1, 1, 6, 6, 6, 6, 1, 1]]],\n    palette: [{ r: 255, g: 255, b: 255 }, { r: 0, g: 0, b: 0 }, { r: 255, g: 0, b: 0 }, { r: 255, g: 64, b: 0 }, { r: 255, g: 128, b: 0 }, { r: 255, g: 191, b: 0 }, { r: 255, g: 255, b: 0 }, { r: 185, g: 246, b: 30 }, { r: 0, g: 255, b: 0 }, { r: 185, g: 255, b: 255 }, { r: 0, g: 255, b: 255 }, { r: 0, g: 0, b: 255 }, { r: 145, g: 0, b: 211 }, { r: 157, g: 48, b: 118 }, { r: 255, g: 0, b: 255 }, { r: 204, g: 27, b: 126 }],\n    fps: 10,\n    transition: MatrixAnimationTransition.None\n});\nregisterMatrixAnimation({\n    frames: [[[1, 1, 2, 2, 2, 2, 1, 1], [1, 2, 2, 2, 2, 2, 2, 1], [2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2], [1, 2, 2, 2, 2, 2, 2, 1], [1, 1, 2, 2, 2, 2, 1, 1]]],\n    palette: [{ r: 255, g: 255, b: 255 }, { r: 0, g: 0, b: 0 }, { r: 255, g: 0, b: 0 }, { r: 255, g: 64, b: 0 }, { r: 255, g: 128, b: 0 }, { r: 255, g: 191, b: 0 }, { r: 255, g: 255, b: 0 }, { r: 185, g: 246, b: 30 }, { r: 0, g: 255, b: 0 }, { r: 185, g: 255, b: 255 }, { r: 0, g: 255, b: 255 }, { r: 0, g: 0, b: 255 }, { r: 145, g: 0, b: 211 }, { r: 157, g: 48, b: 118 }, { r: 255, g: 0, b: 255 }, { r: 204, g: 27, b: 126 }],\n    fps: 10,\n    transition: MatrixAnimationTransition.None\n});\nregisterMatrixAnimation({\n    frames: [[[0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0]]],\n    palette: [{ r: 255, g: 255, b: 255 }, { r: 0, g: 0, b: 0 }, { r: 255, g: 0, b: 0 }, { r: 255, g: 64, b: 0 }, { r: 255, g: 128, b: 0 }, { r: 255, g: 191, b: 0 }, { r: 255, g: 255, b: 0 }, { r: 185, g: 246, b: 30 }, { r: 0, g: 255, b: 0 }, { r: 185, g: 255, b: 255 }, { r: 0, g: 255, b: 255 }, { r: 0, g: 0, b: 255 }, { r: 145, g: 0, b: 211 }, { r: 157, g: 48, b: 118 }, { r: 255, g: 0, b: 255 }, { r: 204, g: 27, b: 126 }],\n    fps: 10,\n    transition: MatrixAnimationTransition.None\n});\nregisterMatrixAnimation({\n    frames: [[[0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 0], [0, 8, 1, 1, 1, 1, 1, 0], [0, 8, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 0], [0, 8, 1, 1, 1, 1, 1, 0], [0, 8, 8, 1, 1, 1, 1, 0], [0, 1, 8, 1, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 0], [0, 8, 1, 8, 1, 1, 1, 0], [0, 8, 8, 8, 1, 1, 1, 0], [0, 1, 8, 1, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 8, 1, 1, 0], [0, 8, 1, 8, 8, 1, 1, 0], [0, 8, 8, 8, 1, 1, 1, 0], [0, 1, 8, 1, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 8, 1, 0], [0, 1, 1, 1, 8, 8, 1, 0], [0, 8, 1, 8, 8, 1, 1, 0], [0, 8, 8, 8, 1, 1, 1, 0], [0, 1, 8, 1, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 8, 0], [0, 1, 1, 1, 1, 8, 8, 0], [0, 1, 1, 1, 8, 8, 1, 0], [0, 8, 1, 8, 8, 1, 1, 0], [0, 8, 8, 8, 1, 1, 1, 0], [0, 1, 8, 1, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0]]],\n    palette: [{ r: 255, g: 255, b: 255 }, { r: 0, g: 0, b: 0 }, { r: 255, g: 0, b: 0 }, { r: 255, g: 64, b: 0 }, { r: 255, g: 128, b: 0 }, { r: 255, g: 191, b: 0 }, { r: 255, g: 255, b: 0 }, { r: 185, g: 246, b: 30 }, { r: 0, g: 255, b: 0 }, { r: 185, g: 255, b: 255 }, { r: 0, g: 255, b: 255 }, { r: 0, g: 0, b: 255 }, { r: 145, g: 0, b: 211 }, { r: 157, g: 48, b: 118 }, { r: 255, g: 0, b: 255 }, { r: 204, g: 27, b: 126 }],\n    fps: 10,\n    transition: MatrixAnimationTransition.None\n});\n\n","modified_on":"2025-09-23T11:24:56.4148000-04:00","program_type":"text","robots":[{"id":18},{"id":19}]}